# 这个设计模式的意图是什么

可以对已有对象的功能进行扩展，以获得更加符合用户需求的对象，使得对象具有更加强大的功能

# 它要解决一个什么问题，

通过它们的子类来对功能进行扩展
* 系统扩展麻烦 因为不支持多重类继承
* 类可以进行扩展但是导致类数目的急剧增加

根本原因在于复用机制的不合理
* 在实现功能复用时，我们要多用关联，少用继
# 它是如何解决的，


# 如何解决
>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为

装饰模式是一种用于替代继承的技术
* 它通过一种无须定义子类的方式来给对象动态增加职责
* 使用对象之间的关联关系取代类之间的继承关系
* 引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能

## 结构图

![image](https://user-images.githubusercontent.com/27160394/140015513-488ae73e-3ba3-4ce8-a158-7238a93756a2.png)

## 角色们
* Component(抽象构件) : 它是具体构件和抽象装饰类的共同父类,声明了在具体构件中实现的业务方法,它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象,实现客户端的透明操作。
* ConcreteComponent(具体构件): 它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责(方法)
* Decorator(抽象装饰类):它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现
  * 它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的
* ConcreteDecorator(具体装饰类):它是抽象装饰类的子类，负责向构件添加新的职
   * 每一个具体装饰类都定义了一些新的行为,它可以调用在抽象装饰类中定义的方法,并可以增加新的方法用以扩充对象的行为

由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任
  * 客户端并不会觉得对象在装饰前和装饰后有什么不同
  * 装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展


## 关键代码
```
class Decorator implements Component
{
       private Component component;  //维持一个对抽象构件对象的引用
       public Decorator(Component component)  //注入一个抽象构件类型的对象
       {
              this.component=component;
       }
 
       public void operation()
       {
              component.operation();  //调用原有业务方法
       }
}
class ConcreteDecorator extends Decorator
{
       public ConcreteDecorator(Component  component){
              super(component);
       }
 
       public void operation(){
              super.operation();  //调用原有业务方法
              addedBehavior();  //调用新增业务方法
       }
 
      //新增业务方法
       public  void addedBehavior(){}
}
```

## 变形
如果客户端希望单独调用具体装饰类新增的方法，而不想通过抽象构件中声明的方法来调用新增方法时将遇到一些麻烦
* 由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，这种装饰模式被称为半透明(Semi-transparent)装饰模式

### 透明装饰模式
要求客户端完全针对抽象编程
* 装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型
* 而应该全部声明为抽象构件类型
```
Component  c, c1; //使用抽象构件类型定义对象
ConcreteDecorator c1; //使用具体装饰类型定义对象(不推荐)
```

### 半透明装饰模式
为了能够调用到新增方法，我们不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式
```
Document  doc; //使用抽象构件类型定义
doc = new PurchaseRequest();
Approver newDoc; //使用具体装饰类型定义
newDoc = new Approver(doc);
```
其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象
* 只需在具体装饰类中增加一个独立的addedBehavior()方法来封装相应的业务处理
* 由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedBehavior()方法来扩展系统功能

# Summary
装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类

## 优点
*  对于扩展一个对象的功能，装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
*  可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为
*  可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象
*  具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”
## 缺点
* 装饰器模式会增加许多子类，过度使用会增加程序得复杂性
* 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能
* 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐

## 在使用时要注意什么
* 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式
* 尽量保持具体构件类ConcreteComponent是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。
* 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类

## 使用场景
* 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时
* 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。
  * 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式
  * 是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长
  * 类已定义为不能被继承(finally)
* 当对象的功能要求可以动态地添加，也可以再动态地撤销时


## 装饰器模式和代理模式之间的差别
* 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问
* 用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息
* 当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器
