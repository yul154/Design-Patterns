# 问题
> 如何运用面向对象的方式来处理这种树形结构.
当容器对象（如文件夹）的某一个方法被调用时
* 将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象）并调用执行，牵一而动百，
* 其中使用了递归调用的机制来对整个结构进行处理。
* 由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，
* 而实际上大多数情况下我们希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂

# 能够想到至少两个它的应用实例，一个生活中的，一个软件中的；
杀毒软件
* 对某个文件夹(Folder)杀毒
* 对某个指定的文件(File)进行杀毒。
* 该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式


## 传统的OOP design

* 文件夹类Folder的设计和实现都非常复杂，需要定义多个集合存储不同类型的成员，而且需要针对不同的成员提供增加、删除和获取等管理和访问成员的方法

* 由于系统没有提供抽象层，客户端代码必须有区别地对待充当容器的文件夹Folder和充当叶子的ImageFile和TextFile，无法统一对它们进行处理

* ，如果需要增加新的类型的叶子和容器都需要对原有代码进行修改，例如如果需要在系统中增加一种新类型的视频文件VideoFile，则必须修改Folder类的源代码


# 它是如何解决的，

组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性

在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编



## 结构图
![image](https://user-images.githubusercontent.com/27160394/140012934-ed579e8f-d7cd-40eb-a746-223a30accb78.png)

## 角色
* Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口
  * 在该角色中可以包含所有子类共有行为的声明和实现。
  * 在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
* Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
* Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点
  * 它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为
  * 包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法



## 记住它的关键代码；
* 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理
* 同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。

```
abstract class Component {  
    public abstract void add(Component c); //增加成员  
    public abstract void remove(Component c); //删除成员  
    public abstract Component getChild(int i); //获取成员  
    public abstract void operation();  //业务方法  
}  
```

* 叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示

```
class Leaf extends Component {  
    public void add(Component c) {   
        //异常处理或错误提示   
    }     
          
    public void remove(Component c) {   
        //异常处理或错误提示   
    }  
      
    public Component getChild(int i) {   
        //异常处理或错误提示  
        return null;   
    }  
      
    public void operation() {  
        //叶子构件具体业务方法的实现  
    }   
}
```
* 在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法,
```
class Composite extends Component {  
    private ArrayList<Component> list = new ArrayList<Component>();  
      
    public void add(Component c) {  
        list.add(c);  
    }  
      
    public void remove(Component c) {  
        list.remove(c);  
    }  
      
    public Component getChild(int i) {  
        return (Component)list.get(i);  
    }  
      
    public void operation() {  
        //容器构件具体业务方法的实现  
        //递归调用成员构件的业务方法  
        for(Object obj:list) {  
            ((Component)obj).operation();  
        }  
    }     
} 
```


# 透明组合模式与安全组合模式
但是由于在AbstractFile中声明了大量用于管理和访问成员构件的方法，例如add()、remove()等方法，我们不得不在新增的文件类中实现这些方法，提供对应的错误提示和异常处理

## 解决方案一
将叶子构件的add()、remove()等方法的实现代码移至AbstractFile类中，由AbstractFile提供统一的默认实现
 * 这样就产生了一种不透明的使用方式，即在客户端不能全部针对抽象构件类编程，需要使用具体叶子构件类型来定义叶子对象

## 解决方案 二
在抽象构件中不声明任何用于访问和管理成员构件的方法
* 客户端不得不使用容器类本身来声明容器构件对象，否则无法访问其中新增的add()、remove()等方法，
* 如果客户端一致性地对待叶子和容器，将会导致容器构件的新增对客户端不可见，客户端代码对于容器构件无法再使用抽象构件来定义

## 透明组合模式

![image](https://user-images.githubusercontent.com/27160394/140014419-630a4944-a401-4e7a-8096-fbc90d5243d4.png)

抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法，
* 好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象
* 缺点是不够安全，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错


## 安全组合模式

![image](https://user-images.githubusercontent.com/27160394/140014434-749ffb78-96f8-446a-a242-a23e0211ecbf.png)


在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法
* 缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。

----

# Summary
实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构

## Pros
* 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
* 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码
* 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改
* 通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。


## Cons
在增加新构件时很难对容器中的构件类型进行限制。
* 有时候我们希望一个容器中只能有某些特定类型的对象，，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，
* 在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。


## 应用场景

* 在需要表示一个对象整体与部分的层次结构的场合。
* 在一个使用面向对象语言开发的系统中需要处理一个树形结构
* 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合
