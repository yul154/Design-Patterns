# 意图

> 引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便

## 它要解决一个什么问题

有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，系统的耦合度将很大
* 此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互



# 如何解决的，
一个子系统的外部与其内部的通信通过一个统一的外观类进行,外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道

外观模式：为子系统中的一组接口提供一个统一的入口。
外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。


# Implementation

![image](https://user-images.githubusercontent.com/27160394/140522475-d52d0694-fcee-488a-a1df-92f0090e6a5c.png)

## 角色们
* Facade(外观角色): 在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；
  * 在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。

*  SubSystem(子系统角色):在软件系统中可以有一个或者多个子系统角色
  *  每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；
  *  每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；
  *  子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已

## 实现
外观模式的主要目的在于降低系统的复杂程度。

* 外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能
```
class SubSystemA  
{  
    public void MethodA()  
    {  
        //业务实现代码  
    }  
}  
  
class SubSystemB  
{  
    public void MethodB()  
    {  
        //业务实现代码  
     }  
} 
```
* 外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大
```
class Facade  
{  
    private SubSystemA obj1 = new SubSystemA();  
    private SubSystemB obj2 = new SubSystemB();  
    private SubSystemC obj3 = new SubSystemC();  
  
    public void Method()  
    {  
        obj1.MethodA();  
        obj2.MethodB();  
        obj3.MethodC();  
    }  
} 
```
* 由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互
```
class Program  
{  
    static void Main(string[] args)  
    {  
        Facade facade = new Facade();  
        facade.Method();  
    }  
}  
```

# 抽象外观类
>  如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则
在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，
* 而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的

# Summary
外观模式并不给系统增加任何新功能，它仅仅是简化调用接口
## 模式优点
* 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。
* 它实现了子系统与客户端之间的松耦合关系，对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易
* 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象

## 模式缺点
* 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性
* 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则

## 适用场景
* 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式
* 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性
* 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度
