# Design-Patterns

Software pattern 
1. what's the question pending to fix
2. Precondition, what's the scenario should be used
3. Solution,How to solve
4. Performance, Benefit and weak point


## 软件设计模式的基本要素
1. 模式名称
2. 问题
3. 解决方案
4. 效果

## 设计模式可分为

1. 创建型(Creational): 主要用于描述如何创建对象
2. 结构型(Structural): 主要用于描述如何实现类或对象的组合
3. 行为型(Behavioral): 主要用于描述类或对象怎样交互以及怎样分配职责


![image](https://user-images.githubusercontent.com/27160394/139584910-735559d5-7045-441d-ad9a-481567cbf226.png)



## 设计模型的考虑方面
* 这个设计模式的意图是什么
* 它要解决一个什么问题，
* 什么时候可以使用它；
* 它是如何解决的，
* 掌握它的结构图，
* 记住它的关键代码；
* 能够想到至少两个它的应用实例，一个生活中的，一个软件中的；
* 这个模式的优缺点是什么，
* 在使用时要注意什么。

# 面向对象设计原则


| 设计原则名称                                   | 定义                       | 使用频率  |
| :--------------------------------------- | :----------------------- | :---- |
| 单一职责原则 (Single Responsibility Principle, SRP) | 一个类只负责一个功能领域中的相应职责       | ★★★★☆ |
| 开闭原则 (Open-Closed Principle, OCP)        | 软件实体应对扩展开放，而对修改关闭        | ★★★★★ |
| 里氏代换原则 (Liskov Substitution Principle, LSP) | 所有引用基类对象的地方能够透明地使用其子类的对象 | ★★★★★ |
| 依赖倒转原则 (Dependence  Inversion Principle, DIP) | 抽象不应该依赖于细节，细节应该依赖于抽象     | ★★★★★ |
| 接口隔离原则 (Interface Segregation Principle, ISP) | 使用多个专门的接口，而不使用单一的总接口     | ★★☆☆☆ |
| 合成复用原则 (Composite Reuse Principle, CRP)  | 尽量使用对象组合，而不是继承来达到复用的目的   | ★★★★☆ |
| 迪米特法则 (Law of Demeter, LoD)              | 一个软件实体应当尽可能少地与其他实体发生相互作用 | ★★★☆☆ |

## 1. 单一职责原则
一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作

## 2. 开闭原则
需要对系统进行抽象化设计，抽象化是开闭原则的关键. 可以通过它们定义系统的抽象层，再通过具体类来进行扩展.

## 3.里氏代换原则
使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象

## 4. 依赖倒转原则

依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象. 要针对接口编程，而不是针对实现编程。一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法
* 在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换
## 5.接口隔离原则
每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干.当一个接口太大时，我们需要将它分割成一些更细小的接口.

## 6.合成复用原则
在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分 提高封装性.
* 如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承

## 7.迪米特法则
一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交
