# 简单工厂模式
>

## 如果按照传统的继承定义一个父实现类
* 很容易违反单一原则和开闭原则。而且
* 客户端只能通过new关键字来直接创建对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离
* 创建对象之前，要进行大量初始化

## 工厂改造
* 创建具体实现类: 将需要创建的各种不同对象的相关代码封装到不同的类中
* 将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类
* 提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象
* 客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。

Simple Facotry Pattern -> 当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节
* 定义一个工厂类
* 根据参数的不同返回不同类的实例
* 被创建的实例通常都具有共同的父类
* 简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式


简单工厂模型中包含如下几个角色
* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法`factoryMethod()`，它的返回类型为抽象产品类型`Product`。
* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。
* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。

```
interface Chart {  
    public void display();  
} 

class HistogramChart implements Chart {  
    public HistogramChart() {  
        System.out.println("创建柱状图！");  
    }  
      
    public void display() {  
        System.out.println("显示柱状图！");  
    }  
}  
  
//饼状图类：具体产品类  
class PieChart implements Chart {  
    public PieChart() {  
        System.out.println("创建饼状图！");  
    }  
      
    public void display() {  
        System.out.println("显示饼状图！");  
    }  
}

class ChartFactory {  
    //静态工厂方法  
    public static Chart getChart(String type) {  
        Chart chart = null;  
        if (type.equalsIgnoreCase("histogram")) {  
            chart = new HistogramChart();  
            System.out.println("初始化设置柱状图！");  
        }  
        else if (type.equalsIgnoreCase("pie")) {  
            chart = new PieChart();  
            System.out.println("初始化设置饼状图！");  
        }  
        else if (type.equalsIgnoreCase("line")) {  
            chart = new LineChart();  
            System.out.println("初始化设置折线图！");              
        }  
        return chart;  
    }  
}  

```
有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类

## 简单工厂模式总结
 重复的创建类的工作其实可以放到一个统一的类中去管理, 简单工厂模式提供了专门的工厂类用于创建对象. 将对象的创建和对象的使用分离开
 
### 主要优点
* 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。
* 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。
* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性

### 主要缺点
* 扩展性差，一旦添加新的子类就不得不修改工厂类的代码，违背开闭原则。在子类较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。
* 由于工厂类集中了所有实例的创建逻辑，厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大.违反了高内聚责任分配原则，它所能创建的类只能是事先考虑到的
* 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

### 适用场景
* 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂
* 客户端只知道传入工厂类的参数，对于如何创建对象并不关心
---
# Factory Method pattern
> 如何实现增加新子类而不影响已有工厂

## 解决简单工厂的扩展性和过于庞大的问题

不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构

## 工厂方法的角色

1. Product ：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
2. ConcreteProduct: 它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
3. Factory : 在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口
4. ConcreteFactory : 它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类

## 扩展
* 在客户端代码中将不再使用new关键字来创建工厂对象
* 而是将具体工厂类的类名存储在配置文件（如XML文件） 通过读取配置文件获取类名字符串，
* 再使用Java的反射机制，根据类名字符串生成对象

## 工厂方法的隐藏
在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。

## 简单工厂模式总结
工厂方法模式是简单工厂模式的进一步抽象和推广, 在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品

### 优点
1. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品
2. 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名
3. 一个调用者想创建一个对象，只要知道其名称就可以了。
4. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。

### 缺点
1. 每次增加一个产品时，都需要增加一个具体类和对象实现工厂, 在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销
2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度

### 适用场景
1. 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即
2. 比如 Hibernate 换数据库只需换方言和驱动就可以

---
# Abstract Factory

**工厂方法的弊端**

1. 工厂方法具有唯一性，针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加
2. 由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱

## 产品族

* 产品等级结构 ： 产品等级结构即产品的继承结构
* 产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品

## 抽象工厂模式概述
抽象工厂模式与工厂方法模式最大的区别在于工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，每一个具体工厂可以生产属于一个产品族的所有产品。

抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类


### 抽象工厂模式结构图中包含如下几个角色

* AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
* ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中
* AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
* ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法

```
interface SkinFactory {  
    public Button createButton();  
    public TextField createTextField();  
    public ComboBox createComboBox();  
} 
```

## 开闭原则”的倾斜性
在抽象工厂模式中，增加新的产品族很方便，抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂, 但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性.

功能增强包括两方面
1. 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改
2. 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则

因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改

## 抽象工厂模式总结

### 优点
* 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
*  增加新的产品族很方便，无须修改已有系统，符合“开闭原则”
*  抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为

### 缺点

* 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”


### 适用场景
* 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来
* 系统结构稳定，不会频繁的增加对象


## 工厂模式的转化
* 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式
* 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式
